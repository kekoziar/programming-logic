# Loops

The nice thing about the terms used for the control structures in most programming languages is they are usually self-describing.  We're going to talk about loops now.  

Loops are common events in programming scripts.  It is what the computer uses to listen for user-input.  It's what researchers use when they want to apply a statistical method over several data files.

## `for` loops

The `for` loop is probably the most common type of loop.  It executes a chunk of code _for_ a certain number of times. The common structure of most `for` loops is

```
for variable in a collection
  do something
```

Now, a collection can be a list of items, like our ingredients, really kind of data structure that has an index, but it can also be a range of numbers, like `1 to 5` (which is literally short for 1 2 3 4 5) or `7 to 13` (which is 7 8 9 10 11 12 13).

Let's see what this looks like in action using our list of cheesy mashed potatoes ingredients

```
ingredients <- cheddar cheese, potatoes, milk, salt, butter

for ingredient in ingredents
  write(ingredient)
```

If we asked a computer to do this using the R language, it would look something like this
<hr>

```{r loop-ingredients}
ingredients <- c("cheddar cheese", "potatoes", "milk", "salt", "butter")
for(ingredient in ingredients){
  print(ingredient)
}
```
<hr>

## Practicing a Trace

But, we want to practice a method of tracing it without the computer doing the work for us. Practicing a trace on things that are simple will help us read complex code without needing to write it down.  

The base set up is like this.  For the original psuedocode, 
```
ingredients <- cheddar cheese, potatoes, milk, salt, butter

for ingredient in ingredents
  write(ingredient)
```
at the top of your paper, write out the `ingredients` assignment.  On the line below that we're going to create headers for all of the variables used within the `for` loop code block.  Starting on the left, write the term `loop iteration`, then `ingredient` in the center of the line, then the term `write` on the right of the line. 

Your paper should look something like this

```{r loop-ingredients-flextable, echo = FALSE, message=FALSE}
library(flextable)
library(officer)
library(shiny)
library(dplyr)

small_border = fp_border(color="gray", width = 1)

ingredients_text <- c("\ningredients <- cheddar cheese, potatoes, milk, salt, butter\n\n")

cName <- c("   ", "loop iteration", " ","ingredient", "  ", "write(ingredient)", "     ") 

ingredients_trace <- matrix(data= " ", nrow = 4, ncol=length(cName))
colnames(ingredients_trace) <- cName
ft <- flextable(as.data.frame(ingredients_trace)) %>%
  align(align = "center", part = "all") %>%
  add_header_row(values=ingredients_text, top=TRUE, colwidths = length(cName)) %>%
  border_remove() %>%
  border_outer(part="all", border = small_border ) %>%
  add_footer_lines(values = c("\n\n ", "\n\n ", "\n\n ", "\n\n "), top = FALSE) %>%
  border_outer(part="footer", border = small_border ) %>%
  border_inner_h(border = small_border, part = "footer")

ft
```

As you were rewriting this, you may have noticed the typo `ingredents` in the for loop. The nice thing about using pseudocode is you don't need to worry about why your code isn't running if there are typos!

Your paper is formatted so it's easy to see what's going on with variable during each loop iteration.  This is called a trace, and is often used in software development to help debug the program.  But, I think it's a good exercise to help build mental muscles to read code.  So, the next is to fill in the values for each iteration of the loop.

Your paper will now look something like this


```{r loop-ingredients-flextable-mid, echo = FALSE, message=FALSE}
library(flextable)
library(officer)
library(shiny)
library(dplyr)
library(ftExtra) #https://ardata-fr.github.io/flextable-book/extensions.html#ftextra

small_border = fp_border(color="gray", width = 1)

ingredients_text <- c("\ningredients <- cheddar cheese, potatoes, milk, salt, butter\n\n")

cName <- c("   ", "loop iteration", " ","ingredient", "  ", "write(ingredient)", "     ") 

ingredients_trace <- data.frame(one=c("", "", "", "", ""),
                                loop=c("1", "2", "3", "4", "5"),
                                three=c("", "", "", "", ""),
                                ingredient=c("cheddar cheese", "potatoes", "milk", "salt", "butter"),
                                five=c("", "", "", "", ""),
                                write=c("cheddar cheese", "potatoes", "milk *(yes, this is a little redundant)*", "salt *(acknowledge the redunancy)*", "butter *(is there an equivalent to horizontal ditto marks?)*"),
                                seven=c("", "", "", "", "")
                                  )
colnames(ingredients_trace) <- cName

ft <- flextable((ingredients_trace)) %>%
  align(align = "center", part = "all") %>%
  add_header_row(values=ingredients_text, top=TRUE, colwidths = length(cName)) %>%
  border_remove() %>%
  border_outer(part="all", border = small_border ) %>%
  add_footer_lines(values = c("\n\n ", "\n\n"), top = FALSE) %>%
  border_outer(part="footer", border = small_border ) %>%
  border_inner_h(border = small_border, part = "all") %>% 
  colformat_md()

ft
```

It's okay if you didn't completely fill out both the variable `ingredient` and the function `write ingredient` because in this case they are the same.  But, it's important to check what actions are happening to variables when you do a trace.

### Exercise - Loop Trace

Now that we've written a text list together, let's practice using ranges.  Remember `2 to 7` represents 2 3 4 5 6 7.

Grab a pen and paper and write out the output of each iteration of the loop:

```
for x in 0 to 5 
  write x
  write x*2
  
```
<details>
<summary>Loop Trace</summary>
```{r loop-exercise-1, echo = FALSE, message=FALSE}
library(flextable)
library(officer)
library(shiny)
library(dplyr)

small_border = fp_border(color="gray", width = 1)

exercise1_text <- c("\nRange 0 to 5 is 0 1 2 3 4 5\n\n")

cName <- c("   ", "loop iteration", " ","write(x)", "  ", "write(x*2)", "     ") 

exercise1_trace <- data.frame(one=c("", "", "", "", "",""),
                                loop=c("1", "2", "3", "4", "5","6"),
                                three=c("", "", "", "","", ""),
                                x=c("0", "1", "2", "3", "4", "5"),
                                five=c("", "", "", "", "",""),
                                write=c("0", "2", "4", "6", "8", "10"),
                                seven=c("", "", "", "", "","")
                                  )
colnames(exercise1_trace) <- cName

ft <- flextable((exercise1_trace)) %>%
  align(align = "center", part = "all") %>%
  add_header_row(values=exercise1_text, top=TRUE, colwidths = length(cName)) %>%
  border_remove() %>%
  border_outer(part="all", border = small_border ) %>%
  add_footer_lines(values = c("\n\n ", "\n\n"), top = FALSE) %>%
  border_outer(part="footer", border = small_border ) %>%
  border_inner_h(border = small_border, part = "all")

ft
```
</details>\


### Exercise - Trace Nested `for` Loops

The following matrix is created using two `for` loops

```{r loop-exercise-2, echo = FALSE}
library(flextable)
library(officer)
library(shiny)
library(dplyr)

# reference: https://davidgohel.github.io/flextable/reference/bg.html

num_rows = 4
num_col = 3
row_names <- list()
matrix_demo <- matrix(nrow=num_rows, ncol = num_col)
for (i in 1:num_rows){
  row_names[i] <- paste0("Row ",i)
  for (j in 1:num_col){
    matrix_demo[i,j] <- (3*(i-1))+(j*2)
  }# end j for loop
}# end i for loop

col_names <- list()
for (j in 1:(num_col)){
  col_names[j] <- paste0("Column ",j)
}
col_names <- c("Index", col_names)


table_demo <-   data.frame(index = unlist(row_names),
                         j1 = matrix_demo[,1],
                         j2 = matrix_demo[,2],
                         j3 = matrix_demo[,3]
                         )

colnames(table_demo) <- col_names

# print(table_demo)

big_border = fp_border(color="black", width = 2)
small_border = fp_border(color="black", width = 1)

ft <- flextable(table_demo) %>% 
      border_remove() %>%
      border_outer(part="all", border = big_border ) %>%
      border_inner_h(part="all", border = small_border ) %>% 
      border_inner_v(part="all", border = small_border ) %>% 
      align(align = "center", part = "all") %>%
      bg(j="Index", bg="gray90", part="body") %>%
      bg(bg="gray90", part="header") %>%
      vline(j="Index", border = big_border, part = "all")
ft 
```


The pseudocode for it is as follows:

```
num_rows = 4
num_col = 3

matrix <- []

for (i in 1 to num_rows)
  for (j in 1 to num_col)
    matrix[i,j] <- (3*(i-1))+(j*2)

```

Before creating the table to help trace the code, answer the following

- What variables need to be traced?
- What are the ranges that are used?
- What calculations do you need to keep track of?
- Is there anything else?

<details>
<summary>Answers</summary>
- What variables need to be traced?
  - `i`, `j`
  - you might think that you need to keep track of `loop iteration`, but it's redundant because both `i` and `j` start at one. it's enough to keep track of just their values.

- What are the ranges that are used?
  - 1 to 4 and 1 to 3

- What calculations do you need to keep track of?
  - `(3*(i-1))+(j*2)`
- Is there anything else?  
  - With a small enough matrix, it's okay to make an empty one and fill it in  
</details><br>

Label columns and sketch out a matrix to fill in the variables as the loop iterates for the first five lines _(you won't fill in the whole matrix, but only a portion)_.

<details>
<summary>Loop Trace</summary>
```{r loop-exercise-2-trace, echo = FALSE, message=FALSE}
library(flextable)
library(officer)
library(shiny)
library(dplyr)
library(ftExtra) #https://ardata-fr.github.io/flextable-book/extensions.html#ftextra

small_border = fp_border(color="gray", width = 1)

exercise2_text_1 <- c("\nnum_rows = 4 & num_col = 3\n\n")
exercise2_text_2 <- c("\nRange 1 to num_rows is 1 2 3 4\n\n")
exercise2_text_3 <- c("\nRange 1 to num_col is 1 2 3\n\n")

cName <- c(" ", "i", "   ", "j", "    ", "(3*(i-1))+(j*2)", "     ") 

exercise1_trace <- data.frame(one=c("", "", "", "", ""),
                                i=c("1", "1", "1", "2", "2"),
                                three=c("", "", "", "", ""),
                                j=c("1", "2", "3", "1", "2"),
                                five=c("", "", "", "", ""),
                                calc=c("(3*(1-1))+(1*2)", "(3*(1-1))+(2*2)", "(3*(1-1))+(3*2)", "(3*(2-1))+(1*2)", "(3*(2-1))+(2*2)"),
                                seven=c("", "", "", "", "")
                                  )
colnames(exercise1_trace) <- cName

ft <- flextable((exercise1_trace)) %>%
  align(align = "center", part = "all") %>%
  add_header_row(values=exercise2_text_3, top=TRUE, colwidths = length(cName)) %>%
  add_header_row(values=exercise2_text_2, top=TRUE, colwidths = length(cName)) %>%
  add_header_row(values=exercise2_text_1, top=TRUE, colwidths = length(cName)) %>%
  border_remove() %>%
  border_outer(part="all", border = small_border ) %>%
  border_outer(part="footer", border = small_border ) %>%
  bg(bg="gray95", part="header") %>%
  bg(i=4, bg="gray90", part="header") %>%
  bold(i=4, bold = TRUE, part = "header") %>%
  italic(i=4, italic = TRUE, part = "header") %>%
  autofit() %>%
  border_inner_h(border = small_border, part = "all")

ft
```


```{r loop-exercise-2-trace-matrix, echo = FALSE}
library(flextable)
library(officer)
library(shiny)
library(dplyr)

# reference: https://davidgohel.github.io/flextable/reference/bg.html

num_rows = 4
num_col = 3
row_names <- list()
matrix_demo <- matrix(nrow=num_rows, ncol = num_col)
for (i in 1:num_rows){
  row_names[i] <- paste0("i = ",i)
  for (j in 1:num_col){
    if(i<2){
      matrix_demo[i,j] <- (3*(i-1))+(j*2)
    }else if(i<3 && j<3){
      matrix_demo[i,j] <- (3*(i-1))+(j*2)
    }else{
      matrix_demo[i,j] <- ""
    }
    
  }# end j for loop
}# end i for loop

col_names <- list()
for (j in 1:(num_col)){
  col_names[j] <- paste0("j = ",j)
}
col_names <- c("Index", col_names)


table_demo <-   data.frame(index = unlist(row_names),
                         j1 = matrix_demo[,1],
                         j2 = matrix_demo[,2],
                         j3 = matrix_demo[,3]
                         )

colnames(table_demo) <- col_names

# print(table_demo)

big_border = fp_border(color="black", width = 2)
small_border = fp_border(color="black", width = 1)

ft <- flextable(table_demo) %>% 
      border_remove() %>%
      border_outer(part="all", border = big_border ) %>%
      border_inner_h(part="all", border = small_border ) %>% 
      border_inner_v(part="all", border = small_border ) %>% 
      align(align = "center", part = "all") %>%
      bg(j="Index", bg="gray90", part="body") %>%
      bg(bg="gray90", part="header") %>%
      vline(j="Index", border = big_border, part = "all")
ft 
```


</details>\

<hr>

## Other Types of Loops 

There are other types of loops in addition to the commonly used `for` loop.\ 

The `while` loop uses a condition at the start of the loop to determine, in advance, when the loop will stop. 

```
while (condition is TRUE)
  do something
```

For this loop to work, you need to set the condition *before* the loop, and change it *in* the loop.

For example, recall the initial for loop:

```
ingredients <- cheddar cheese, potatoes, milk, salt, butter

for ingredient in ingredents
  write(ingredient)
```

An equivalent `while` loop would look like:

```
ingredients <- cheddar cheese, potatoes, milk, salt, butter

i = 1
condition_check = length(ingredients) + 1 
while i < condition_check
  write ingredients[i]
  i <- i + 1 // change for condition check
```

Here's what it look like in R

``` {r while-loop}
ingredients <- c("cheddar cheese", "potatoes", "milk", "salt", "butter")

i <- 1
condition_check = length(ingredients) + 1

while(i < condition_check){
  print(ingredients[i])
  i <- i + 1
}
```

<hr>

Two other types of loops are a `do while` loop (check at end) and an `until` loop (check at end).

```
do
  something
while (condition is TRUE)

```

The logic in the `do while` loop is while a condition is true, the loop will run.  
As with the `while` loop, the condition needs to be set before the loop, and changed within the loop.

For the `until` loop, it's slightly different. The loop structure is like this

```
do
  something
until (condition is TRUE)

```

The logic is opposite of a `do while` loop.  It will run while the condition is false, and will only exit when the condition is true.

These aren't used often, in fact IMO it's better to just re-write the logic to use a `while` loop. 

### While Trace
Let's practice a `while` combined with a `for` trace 

```
condition_check <- 5
i <- 1
while (i < condition_check):
  for j in 1 to 3:
    write (i*j)+i

```

I'll give you all a few minutes to write out your trace.  Once you're done, 
type the largest number you traced in the write statement, but don't press enter until I give the signal.

<hr>
<hr>
## Caveats

As you've just experienced, loops come with their own set of common issues.  
Since loops are a frequently encountered concept in programming, we'll go over the common problems.

### Infinite loops

What you all just experienced in the previous exercise is called an infinite loop.  Infinite loops happen when the condition check is never false.  In the case
of the above while loop, the check variable was never incremented, so the loop would go through the same process until the programmer interrupts it, the computer fails, or time ends (whichever comes first). 

### Overwriting outputs

```
for x in files(1 to 500) 
  rename_file(x, "test-case")
```

Often when researchers are developing a script, they will use test case to develop their algorithm and work out the bugs.  In this way, if mistakes are made, it's on a small scale and easy to correct.  Most development is the following.

1. Develop code for a single case
2. Test on a few cases
3. Use on all of the cases

If a step is missed, it can be disastrous.  I can attest. I wrote a script to rename about 500 files, and in my hubris of being an awesome coder, forgot to test it on a few cases before using it on all of the files. I forgot to change the single rename `("test-case")` to something that incorporated the loop `("test-case"+x)` and when the loop was finished, wondered why I went from 500 to only one file in the folder.  Luckily, I always backup my data files, so it was an easy mistake to remedy _(and makes for a good story on the importance of data backup)_.

